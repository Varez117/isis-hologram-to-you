<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Ti ❤️</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Consolas', monospace; }
        canvas { display: block; }
        
        /* --- UI DE VIDEO --- */
        #input_video {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            z-index: 2; border-radius: 8px;
            transform: scaleX(-1);
            border: 1px solid #ff0055; opacity: 0; /* Invisible al inicio */
            transition: opacity 1s, filter 0.3s;
            object-fit: cover;
        }
        #input_video.active { opacity: 0.4; }
        #input_video.inactive {
            filter: grayscale(100%) brightness(30%);
            opacity: 0.2;
        }

        /* --- UI TEXTOS --- */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: rgba(255, 100, 150, 0.9); pointer-events: none;
            display: none; /* Se activa tras el intro */
        }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 2px; border-bottom: 1px solid rgba(255,0,100,0.5); padding-bottom: 5px; display: inline-block;}
        .status { font-size: 0.8rem; margin-top: 8px; }

        /* --- PANTALLA DE INTRODUCCIÓN --- */
        #intro-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #2a0015 0%, #000000 100%);
            z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s ease-out;
        }
        
        #start-btn {
            background: transparent;
            color: #ff0055;
            border: 2px solid #ff0055;
            padding: 15px 40px;
            font-size: 1.2rem;
            letter-spacing: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);
            transition: all 0.4s;
            border-radius: 4px;
        }
        #start-btn:hover {
            background: #ff0055;
            color: white;
            box-shadow: 0 0 40px rgba(255, 0, 85, 0.8);
            transform: scale(1.05);
        }

        /* --- MENSAJE OCULTO --- */
        #hidden-message {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Segoe UI', 'Helvetica', sans-serif;
            font-weight: 300;
            font-size: 3.5rem;
            color: #fff;
            text-shadow: 0 0 10px #ff0055, 0 0 30px #ff0055, 0 0 60px #ff0080;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.5s ease, transform 0.5s ease;
            text-align: center;
            white-space: nowrap;
            letter-spacing: 4px;
        }

        /* --- CONTROLES MANUALES (CAMARA OFF) --- */
        #cam-toggle {
            position: absolute; bottom: 150px; right: 20px; z-index: 10;
            background: rgba(0,0,0,0.7); border: 1px solid #ff0055;
            color: #ff0055; padding: 10px 15px; cursor: pointer;
            font-family: 'Consolas', monospace; text-transform: uppercase;
            border-radius: 4px; transition: all 0.3s;
            display: none; /* Se muestra tras el intro */
        }
        #cam-toggle:hover { background: #ff0055; color: #000; }

        #manual-controls {
            display: none; 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 320px; padding: 15px; z-index: 10;
            background: rgba(10, 0, 10, 0.9);
            border: 1px solid #ff0055; border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.2);
            max-height: 400px; overflow-y: auto;
        }
        
        .control-group { margin-bottom: 8px; }
        .control-group label { display: flex; justify-content: space-between; color: #ff99bb; font-size: 0.75rem; margin-bottom: 2px; }
        .control-group input { width: 100%; cursor: pointer; accent-color: #ff0055; height: 10px; }
        .sim-title { text-align: center; color: #fff; border-bottom: 1px solid #333; margin-bottom: 10px; font-size: 0.9rem; padding-bottom: 5px;}
    
        /* --- ESTILO LUCIÉRNAGAS --- */
        .firefly {
            position: absolute; border-radius: 50%; pointer-events: none;
            mix-blend-mode: screen; background-color: #ffdc60; 
            animation: hover infinite alternate ease-in-out, flash infinite ease-in-out;
        }
        @keyframes hover { 0% { transform: translate(0, 0); } 100% { transform: translate(15px, -15px); } }
        @keyframes flash { 0%, 100% { opacity: 0.2; } 50% { opacity: 1; } }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="intro-screen">
        <h2 style="color: #ff99cc; font-weight: 300; margin-bottom: 40px; letter-spacing: 2px;">Tengo algo para mostrarte...</h2>
        <button id="start-btn">VER SORPRESA</button>
        <p style="color:#555; margin-top:20px; font-size:0.7rem;">(Requiere cámara y audio)</p>
    </div>

    <audio id="bg-music" loop>
        <source src="https://assets.codepen.io/296057/romantic_piano.mp3" type="audio/mpeg">
    </audio>

    <div id="ui-layer">
        <h1>PROJECT: TULIP</h1>
        <div class="status" id="status-text">ESPERANDO MANO...</div>
        <div class="status" id="debug-state">ESTADO: DISPERSO</div>
    </div>

    <div id="hidden-message">TE AMO ❤️</div>

    <video id="input_video" autoplay playsinline muted></video>
    
    <button id="cam-toggle">APAGAR CÁMARA / MANUAL</button>

    <div id="manual-controls">
        <div class="sim-title">CONTROL MANUAL</div>
        
        <div class="control-group">
            <label><span>APERTURA (Mensaje)</span></label>
            <input type="range" id="sim-open" min="0" max="1" step="0.01" value="1">
        </div>
        <div class="control-group">
            <label>ROTACIÓN X</label>
            <input type="range" id="sim-rot-x" min="-3.14" max="3.14" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>ROTACIÓN Y</label>
            <input type="range" id="sim-rot-y" min="-3.14" max="3.14" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>POSICIÓN Y</label>
            <input type="range" id="sim-y" min="-20" max="20" step="0.1" value="0">
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uExplosion; 
        uniform vec3 uInertia;
        
        attribute float aSize;
        attribute float aRandom;
        
        varying vec3 vPos;
        varying float vAlpha;

        void main() {
            vec3 pos = position;

            // Ruido orgánico
            float noiseX = sin(uTime * 2.0 + aRandom * 10.0);
            float noiseY = cos(uTime * 1.5 + aRandom * 20.0);
            float noiseZ = sin(uTime * 2.5 + aRandom * 30.0);
            vec3 noiseVec = vec3(noiseX, noiseY, noiseZ);

            // Respiración base
            pos += noiseVec * 0.2; 

            // --- LÓGICA DE EXPLOSIÓN ---
            // Cuando explota, se vuelve caótico
            vec3 explosionDir = normalize(pos) * (20.0 + aRandom * 30.0);
            vec3 chaoticPos = pos + explosionDir + (noiseVec * 2.0);
            pos = mix(pos, chaoticPos, uExplosion);

            // --- LÓGICA DE ARRASTRE ---
            float dragFactor = aRandom * aRandom * 1.5; 
            pos -= uInertia * dragFactor;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            float sizeMod = 1.0 + uExplosion * 1.5; 
            gl_PointSize = (4.0 * aSize * sizeMod) * (60.0 / -mvPosition.z);
            
            vPos = position;
            // No desvanecemos del todo para que las partículas brillen alrededor del texto
            vAlpha = 1.0 - (uExplosion * 0.2); 
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float uExplosion; 
        varying vec3 vPos;
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            // Círculo suave en vez de discard (mejor rendimiento móvil)
            float circle = 1.0 - smoothstep(0.4, 0.5, dist);
            if (circle < 0.01) discard;

            float height = smoothstep(-10.0, 20.0, vPos.y);
            
            // COLORES ROMÁNTICOS
            vec3 deepRed = vec3(0.8, 0.0, 0.2); 
            vec3 softPink = vec3(1.0, 0.6, 0.8); 
            vec3 gold = vec3(1.0, 0.9, 0.5); // Color dorado para la explosión
            
            vec3 color = mix(deepRed, softPink, height);
            
            // Al explotar, brillan un poco en dorado
            color = mix(color, gold, uExplosion * 0.6);
            color = mix(color, vec3(1.0), pow(height, 3.0) * 0.5); 

            // Tallo verde oscuro
            if(vPos.y < -8.0) {
                color = mix(color, vec3(0.0, 0.5, 0.2), 0.7 * (1.0 - uExplosion));
            }

            float strength = circle * vAlpha;
            gl_FragColor = vec4(color, strength);
        }
    </script>

    <script>
        // CONFIGURACIÓN INICIAL
        const config = { rotLerp: 0.04, posLerp: 0.05, baseZ: -5 };
        const state = {
            targetQuat: new THREE.Quaternion(),
            currentQuat: new THREE.Quaternion(),
            targetPos: new THREE.Vector3(0, -5, config.baseZ),
            currentPos: new THREE.Vector3(0, -5, config.baseZ),
            prevPos: new THREE.Vector3(0, -5, config.baseZ),
            inertia: new THREE.Vector3(0, 0, 0),
            handDetected: false,
            handOpenness: 1.0, // Empieza abierto (disperso)
            smoothedOpenness: 1.0 
        };

        // UI ELEMENTS
        const els = {
            intro: document.getElementById('intro-screen'),
            startBtn: document.getElementById('start-btn'),
            uiLayer: document.getElementById('ui-layer'),
            status: document.getElementById('status-text'),
            debug: document.getElementById('debug-state'),
            video: document.getElementById('input_video'),
            toggleBtn: document.getElementById('cam-toggle'),
            manualControls: document.getElementById('manual-controls'),
            hiddenMsg: document.getElementById('hidden-message'),
            bgMusic: document.getElementById('bg-music'),
            // Sliders
            simOpen: document.getElementById('sim-open'),
            simRotX: document.getElementById('sim-rot-x'),
            simRotY: document.getElementById('sim-rot-y'),
            simY: document.getElementById('sim-y')
        };

        let simulationMode = false;
        let experienceStarted = false;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050005, 0.015);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;
        camera.position.y = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- GEOMETRÍA TULIPÁN ---
        const geometry = new THREE.BufferGeometry();
        const count = 35000;
        const positions = [];
        const sizes = [];
        const randoms = [];

        for(let i=0; i<count; i++) {
            let u = Math.random();
            let v = Math.random() * Math.PI * 2;
            // Forma matemática de tulipán
            let radius = 3.0 + (u * 8.0) + (Math.sin(u * Math.PI) * 4.0);
            let petals = Math.sin(v * 3.0); 
            radius += petals * (u * 3.0);
            let x = radius * Math.cos(v);
            let z = radius * Math.sin(v);
            let y = (u * 25.0) - 10.0; 
            
            // Random jitter
            x += (Math.random() - 0.5) * 0.5;
            y += (Math.random() - 0.5) * 0.5;
            z += (Math.random() - 0.5) * 0.5;

            positions.push(x, y, z);
            sizes.push(0.5 + Math.random());
            randoms.push(Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: { 
                uTime: { value: 0 },
                uExplosion: { value: 1.0 },
                uInertia: { value: new THREE.Vector3(0,0,0) }
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const flower = new THREE.Points(geometry, material);
        scene.add(flower);

        // --- LOOP DE ANIMACIÓN ---
        const clock = new THREE.Clock();
        const eulerDummy = new THREE.Euler();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;

            // Suavizado del valor de apertura
            state.smoothedOpenness += (state.handOpenness - state.smoothedOpenness) * 0.05;
            material.uniforms.uExplosion.value = state.smoothedOpenness;

            // --- LÓGICA DEL MENSAJE SECRETO ---
            // Si la flor está "abierta" (explotada), mostramos el mensaje
            if (state.smoothedOpenness > 0.6) {
                let opacity = (state.smoothedOpenness - 0.6) * 2.5;
                els.hiddenMsg.style.opacity = Math.min(opacity, 1);
                let scale = 1 + (state.smoothedOpenness * 0.1);
                els.hiddenMsg.style.transform = `translate(-50%, -50%) scale(${scale})`;
            } else {
                els.hiddenMsg.style.opacity = 0;
            }

            // Movimiento
            if (state.handDetected || simulationMode) {
                state.currentQuat.slerp(state.targetQuat, config.rotLerp);
                flower.quaternion.copy(state.currentQuat);
                state.currentPos.lerp(state.targetPos, config.posLerp);
                flower.position.copy(state.currentPos);
            } else {
                // Modo Idle (flotando suave)
                state.targetPos.set(0, -5, config.baseZ);
                state.currentPos.lerp(state.targetPos, 0.02); 
                flower.position.copy(state.currentPos);
                flower.rotation.y += 0.002;
                state.handOpenness = 1.0; // En idle se mantiene dispersa (bonito)
            }

            // Física de Inercia
            const movement = new THREE.Vector3().subVectors(state.currentPos, state.prevPos);
            state.inertia.add(movement);
            state.inertia.multiplyScalar(.92); // Fricción
            material.uniforms.uInertia.value.copy(state.inertia);
            state.prevPos.copy(state.currentPos);

            renderer.render(scene, camera);
        }
        animate();

        // --- MEDIAPIPE LOGIC ---
        function onResults(results) {
            if (!experienceStarted || simulationMode) return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                if(!state.handDetected) {
                    state.handDetected = true;
                    els.status.innerText = "CONECTADO A TI";
                    els.status.style.color = "#ff0080";
                }

                // Posición
                let x = (0.5 - lm[9].x) * 50; 
                let y = (0.5 - lm[9].y) * 40;
                const handScale = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                let z = THREE.MathUtils.mapLinear(handScale, 0.05, 0.4, -40, 20);
                z = THREE.MathUtils.clamp(z, -50, 20); // Evitar clipping
                state.targetPos.set(x, y, z);

                // Apertura (Openness)
                const tips = [8, 12, 16, 20];
                let totalDist = 0;
                tips.forEach(idx => {
                    totalDist += Math.hypot(lm[idx].x - lm[0].x, lm[idx].y - lm[0].y);
                });
                const palmSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                const ratio = (totalDist / 4) / palmSize; 
                let openness = THREE.MathUtils.mapLinear(ratio, 1.0, 1.9, 0, 1);
                openness = THREE.MathUtils.clamp(openness, 0, 1);
                state.handOpenness = openness;

                if (openness < 0.3) {
                    els.debug.innerText = "ESTADO: FORMANDO FLOR";
                    els.debug.style.color = "#fff";
                } else {
                    els.debug.innerText = "ESTADO: DISPERSANDO";
                    els.debug.style.color = "#ff6699";
                }

                // Rotación
                const vWrist = new THREE.Vector3(-lm[0].x, -lm[0].y, lm[0].z);
                const vIndex = new THREE.Vector3(-lm[5].x, -lm[5].y, lm[5].z);
                const vPinky = new THREE.Vector3(-lm[17].x, -lm[17].y, lm[17].z);
                
                const vA = new THREE.Vector3().subVectors(vIndex, vWrist).normalize();
                const vB = new THREE.Vector3().subVectors(vPinky, vWrist).normalize();
                const vNormal = new THREE.Vector3().crossVectors(vA, vB).normalize();
                const vUp = vA.clone();
                const vRight = new THREE.Vector3().crossVectors(vUp, vNormal).normalize();
                vUp.crossVectors(vNormal, vRight).normalize();

                const mRotation = new THREE.Matrix4().makeBasis(vRight, vUp, vNormal);
                state.targetQuat.setFromRotationMatrix(mRotation);

            } else {
                if(state.handDetected) {
                    state.handDetected = false;
                    els.status.innerText = "BUSCANDO TU MANO...";
                    els.status.style.color = "#777";
                }
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        // Inicialización de cámara (PERO NO START TODAVÍA)
        const cameraUtils = new Camera(els.video, {
            onFrame: async () => { 
                if(experienceStarted && !simulationMode) {
                    await hands.send({image: els.video}); 
                }
            },
            width: 640, height: 480
        });

        // --- INTERACCIÓN DE USUARIO ---

        // 1. CLICK EN EL BOTÓN DE INICIO
        els.startBtn.addEventListener('click', () => {
            // Desvanecer intro
            els.intro.style.opacity = '0';
            setTimeout(() => { 
                els.intro.style.display = 'none'; 
                els.uiLayer.style.display = 'block';
                els.toggleBtn.style.display = 'block';
            }, 1500);

            // Audio
            els.bgMusic.volume = 0.5;
            els.bgMusic.play().catch(e => console.log("Audio play failed req interaction", e));

            // Iniciar cámara
            experienceStarted = true;
            els.video.classList.add('active');
            cameraUtils.start();
        });

        // 2. TOGGLE CÁMARA / MANUAL
        els.toggleBtn.addEventListener('click', () => {
            simulationMode = !simulationMode;

            if (simulationMode) {
                // MODO MANUAL (SLIDERS)
                els.toggleBtn.innerText = "ACTIVAR CÁMARA";
                els.video.classList.remove('active');
                els.video.classList.add('inactive');
                els.manualControls.style.display = 'block';
                els.status.innerText = "CONTROL MANUAL";
                updateSimulation();
            } else {
                // MODO CÁMARA
                els.toggleBtn.innerText = "APAGAR CÁMARA / MANUAL";
                els.video.classList.remove('inactive');
                els.video.classList.add('active');
                els.manualControls.style.display = 'none';
                els.status.innerText = "BUSCANDO TU MANO...";
                
                // Si la cámara no estaba corriendo, aseguramos start
                if(experienceStarted) cameraUtils.start();
            }
        });

        // 3. LOGICA SLIDERS
        function updateSimulation() {
            if (!simulationMode) return;
            
            state.handDetected = true;
            state.handOpenness = parseFloat(els.simOpen.value);
            
            // Texto Debug
            if (state.handOpenness < 0.3) {
                els.debug.innerText = "ESTADO: FORMANDO (SIM)";
                els.debug.style.color = "#fff";
            } else {
                els.debug.innerText = "ESTADO: DISPERSO (SIM)";
                els.debug.style.color = "#ff6699";
            }

            // Posición
            state.targetPos.set(0, parseFloat(els.simY.value), -20);

            // Rotación
            const rX = parseFloat(els.simRotX.value);
            const rY = parseFloat(els.simRotY.value);
            eulerDummy.set(rX, rY, 0, 'XYZ');
            state.targetQuat.setFromEuler(eulerDummy);
        }

        els.simOpen.addEventListener('input', updateSimulation);
        els.simRotX.addEventListener('input', updateSimulation);
        els.simRotY.addEventListener('input', updateSimulation);
        els.simY.addEventListener('input', updateSimulation);

        // --- EXTRAS VISUALES (Luciérnagas) ---
        function createFireflies() {
            for (let i = 0; i < 40; i++) {
                const f = document.createElement('div');
                f.classList.add('firefly');
                document.body.appendChild(f);
                f.style.top = Math.random() * 100 + 'vh';
                f.style.left = Math.random() * 100 + 'vw';
                const s = Math.random() * 3 + 2; 
                f.style.width = s + 'px'; f.style.height = s + 'px';
                f.style.opacity = Math.random() * 0.5 + 0.3;
                f.style.animationDuration = (Math.random() * 10 + 10) + 's, ' + (Math.random() * 2 + 1) + 's';
                f.style.animationDelay = '-' + Math.random() * 10 + 's';
            }
        }
        createFireflies();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
