<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Tulip Interface</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050005; font-family: 'Consolas', monospace; }
        canvas { display: block; }
        
        #input_video {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            z-index: 2; border-radius: 8px;
            transform: scaleX(-1);
            border: 1px solid #ff0055; opacity: 0.4;
            transition: opacity 0.3s;
        }
        #input_video:hover { opacity: 1; }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 3;
            color: rgba(255, 100, 150, 0.9); pointer-events: none;
        }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 2px; border-bottom: 1px solid rgba(255,0,100,0.5); padding-bottom: 5px; display: inline-block;}
        .status { font-size: 0.8rem; margin-top: 8px; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-size: 1.2rem; text-shadow: 0 0 10px #ff0055;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">GENERATING FLORA...</div>
    <div id="ui-layer">
        <h1>PROJECT: TULIP</h1>
        <div class="status" id="status-text">WAITING FOR HAND...</div>
        <div class="status" id="debug-state">STATE: DISPERSED</div>
    </div>
    <video id="input_video"></video>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uExplosion; // 0 = Forma, 1 = Dispersión
        attribute float aSize;
        attribute float aRandom;
        varying vec3 vPos;
        varying float vAlpha;

        // Función de ruido simple
        float random (vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            vec3 pos = position;

            // --- LÓGICA DE DISPERSIÓN ---
            // Si uExplosion es alto, movemos las partículas en direcciones caóticas
            float noiseX = sin(uTime * 2.0 + aRandom * 10.0) * 2.0;
            float noiseY = cos(uTime * 1.5 + aRandom * 20.0) * 2.0;
            float noiseZ = sin(uTime * 2.5 + aRandom * 30.0) * 2.0;
            
            vec3 explosionDir = normalize(pos) * (20.0 + aRandom * 30.0);
            vec3 chaoticPos = pos + explosionDir + vec3(noiseX, noiseY, noiseZ);
            
            // Interpolamos entre la forma original (pos) y la caótica
            pos = mix(pos, chaoticPos, uExplosion);

            // Rotación suave siempre activa
            float angle = uTime * 0.2; 
            float s = sin(angle); float c = cos(angle);
            float x = pos.x * c - pos.z * s;
            float z = pos.x * s + pos.z * c;
            pos.x = x; pos.z = z;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            // El tamaño crece un poco al explotar para dar efecto de "energía"
            float sizeMod = 1.0 + uExplosion * 1.5;
            gl_PointSize = (4.0 * aSize * sizeMod) * (60.0 / -mvPosition.z);
            
            vPos = position; // Pasamos la posición original para colorear
            
            // Desvanecer un poco si está muy explotado
            vAlpha = 1.0 - (uExplosion * 0.5);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vPos;
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if(dist > 0.5) discard;

            // --- COLOREADO TULIPÁN ---
            // Base rosa oscuro, puntas rosa claro/blanco
            
            // Normalizamos la altura aproximada del tulipan (-10 a 20)
            float height = smoothstep(-10.0, 20.0, vPos.y);
            
            vec3 darkPink = vec3(0.8, 0.0, 0.4); // Rosa profundo / Magenta
            vec3 lightPink = vec3(1.0, 0.6, 0.8); // Rosa pastel
            vec3 white = vec3(1.0, 1.0, 1.0);     // Puntas blancas
            
            vec3 color = mix(darkPink, lightPink, height);
            color = mix(color, white, pow(height, 3.0)); // Puntas más blancas

            // Un toque de verde en la base muy inferior
            if(vPos.y < -8.0) {
                color = mix(color, vec3(0.0, 0.5, 0.2), 0.7);
            }

            // Brillo en el centro de la partícula
            float strength = 1.0 - (dist * 2.0);
            strength = pow(strength, 1.5);

            gl_FragColor = vec4(color, strength * vAlpha * 0.9);
        }
    </script>

    <script>
        const config = {
            rotLerp: 0.1,  
            posLerp: 0.1,  
            baseZ: -5, // Acercarlo un poco más
            openThreshold: 0.6 // Umbral para decidir si la mano está abierta
        };

        const state = {
            targetQuat: new THREE.Quaternion(),
            currentQuat: new THREE.Quaternion(),
            targetPos: new THREE.Vector3(0, -5, config.baseZ),
            currentPos: new THREE.Vector3(0, -5, config.baseZ),
            handDetected: false,
            handOpenness: 1.0, // 0 = cerrado, 1 = abierto
            smoothedOpenness: 1.0 // Para animación suave
        };

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        // Niebla rosada oscura
        scene.fog = new THREE.FogExp2(0x050005, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;
        camera.position.y = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- GEOMETRÍA DEL TULIPÁN ---
        const geometry = new THREE.BufferGeometry();
        const count = 35000;
        const positions = [];
        const sizes = [];
        const randoms = [];

        for(let i=0; i<count; i++) {
            // Generación Paramétrica de un Tulipán
            // u = altura (0 a 1), v = ángulo (0 a 2PI)
            let u = Math.random();
            let v = Math.random() * Math.PI * 2;
            
            // Radio base que se ensancha hacia arriba (forma de copa)
            // Curva cuadrática para la base bulbosa
            let radius = 3.0 + (u * 8.0) + (Math.sin(u * Math.PI) * 4.0);
            
            // Modulación de pétalos (3 pétalos internos, 3 externos simulados)
            // Ondulación sinusoidal en el radio basada en el ángulo
            let petals = Math.sin(v * 3.0); 
            
            // Los pétalos se abren más arriba
            radius += petals * (u * 3.0);
            
            // Coordenadas
            let x = radius * Math.cos(v);
            let z = radius * Math.sin(v);
            let y = (u * 25.0) - 10.0; // Altura de -10 a 15
            
            // Añadir un poco de ruido aleatorio para que parezca polen/partículas
            x += (Math.random() - 0.5) * 0.5;
            y += (Math.random() - 0.5) * 0.5;
            z += (Math.random() - 0.5) * 0.5;

            positions.push(x, y, z);
            sizes.push(0.5 + Math.random());
            randoms.push(Math.random());
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: { 
                uTime: { value: 0 },
                uExplosion: { value: 1.0 } // Empieza disperso
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const flower = new THREE.Points(geometry, material);
        scene.add(flower);

        // --- LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value = clock.getElapsedTime();

            // Suavizado de la variable de explosión/apertura
            state.smoothedOpenness += (state.handOpenness - state.smoothedOpenness) * 0.1;
            material.uniforms.uExplosion.value = state.smoothedOpenness;

            if (state.handDetected) {
                // Rotación sigue a la mano
                state.currentQuat.slerp(state.targetQuat, config.rotLerp);
                flower.quaternion.copy(state.currentQuat);

                // Posición sigue a la mano
                state.currentPos.lerp(state.targetPos, config.posLerp);
                flower.position.copy(state.currentPos);
                
            } else {
                // Si no hay mano, flota suavemente en el centro y se dispersa
                state.targetPos.set(0, -5, config.baseZ);
                state.currentPos.lerp(state.targetPos, 0.05);
                flower.position.copy(state.currentPos);
                
                // Rotación automática lenta
                flower.rotation.y += 0.002;
                
                // Se dispersa lentamente si no hay mano
                state.handOpenness = 1.0; 
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- VECTORES AUXILIARES ---
        const vWrist = new THREE.Vector3();
        const vIndex = new THREE.Vector3();
        const vPinky = new THREE.Vector3();
        const vA = new THREE.Vector3();
        const vB = new THREE.Vector3();
        const vNormal = new THREE.Vector3(); 
        const vUp = new THREE.Vector3();    
        const vRight = new THREE.Vector3();  
        const mRotation = new THREE.Matrix4();
        const qDummy = new THREE.Quaternion();

        // --- MEDIAPIPE ---
        const els = {
            loading: document.getElementById('loading'),
            status: document.getElementById('status-text'),
            debug: document.getElementById('debug-state')
        };

        function onResults(results) {
            els.loading.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];

                if(!state.handDetected) {
                    state.handDetected = true;
                    els.status.innerText = "LINK ESTABLISHED";
                    els.status.style.color = "#ff0080";
                }

                // --- POSICIÓN ---
                // Mapear coordenadas 2D a 3D
                let x = (0.5 - lm[9].x) * 50; 
                let y = (0.5 - lm[9].y) * 40;
                
                // Profundidad aproximada basada en tamaño de la mano
                // (Distancia muñeca a dedo medio)
                const handScale = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                let z = THREE.MathUtils.mapLinear(handScale, 0.05, 0.4, -40, 20);

                state.targetPos.set(x, y, z);

                // --- DETECCIÓN DE APERTURA DE MANO (OPEN/CLOSE) ---
                // Calculamos la distancia promedio de las puntas de los dedos a la muñeca (punto 0)
                // Puntas: 8 (Indice), 12 (Medio), 16 (Anular), 20 (Meñique)
                const tips = [8, 12, 16, 20];
                let totalDist = 0;
                
                tips.forEach(idx => {
                    const d = Math.hypot(lm[idx].x - lm[0].x, lm[idx].y - lm[0].y);
                    totalDist += d;
                });
                
                // Normalizamos un poco la distancia con respecto al tamaño de la palma (0 a 9)
                const palmSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                const ratio = (totalDist / 4) / palmSize; // Promedio relativo

                // Ratio > 1.8 suele ser mano abierta, Ratio < 1.2 suele ser puño
                // Mapeamos ratio a 0 (Cerrado) - 1 (Abierto)
                let openness = THREE.MathUtils.mapLinear(ratio, 1.0, 1.9, 0, 1);
                openness = THREE.MathUtils.clamp(openness, 0, 1);

                state.handOpenness = openness;

                // UI Feedback
                if (openness < 0.3) {
                    els.debug.innerText = "STATE: FORMING TULIP";
                    els.debug.style.color = "#fff";
                } else {
                    els.debug.innerText = "STATE: DISPERSING";
                    els.debug.style.color = "#ff6699";
                }

                // --- ROTACIÓN ---
                const zMult = 1.0; 
                vWrist.set(-lm[0].x, -lm[0].y, lm[0].z * zMult);
                vIndex.set(-lm[5].x, -lm[5].y, lm[5].z * zMult);
                vPinky.set(-lm[17].x, -lm[17].y, lm[17].z * zMult);

                vA.subVectors(vIndex, vWrist).normalize();
                vB.subVectors(vPinky, vWrist).normalize();
                vNormal.crossVectors(vA, vB).normalize();

                vUp.copy(vA);
                vRight.crossVectors(vUp, vNormal).normalize();
                vUp.crossVectors(vNormal, vRight).normalize();

                mRotation.makeBasis(vRight, vUp, vNormal);
                qDummy.setFromRotationMatrix(mRotation);
                state.targetQuat.copy(qDummy);

            } else {
                if(state.handDetected) {
                    state.handDetected = false;
                    els.status.innerText = "SEARCHING HAND...";
                    els.status.style.color = "#777";
                }
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
